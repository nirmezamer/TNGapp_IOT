Let's first talk about shellcode.asm:

*** All the plt's for libc function calls were acquired by disassembling dummy() with gdb ***
 
It will act similarly to q2.c:
First it will call socket to create socket.
Afterwards it will use connect() for connecting to 127.0.0.1 port 1337 (the netcat server listens there).
Notice that we dropped the call for htons(1337) and inet_address("127.0.0.1") for saving some shellcode size.
Instead we hardcoded their results into shellcode.asm.
Afterwards we called dup2() 3 times for setting up IO to the connected socket.
At last we called execv() for running "/bin/sh"
For getting the string "/bin/sh" I used the "jmp _want/_got_bin_bash" trick we've seen in the recitation.


Let's discuss q2.py:

get_shellcode() just assembles shellcode.asm using the course's infosec.core module.
get_payload() uses a similar method to as in the previous exercise for building the final payload.
First we call get_shellcode(). Then we create a nop slide that will pad the bottom of the input buffer.
To that we concatenate the fabricated return address: the middle of the nop slide.
Finally we calculate the corresponding length bytes, concatenate the above described message bytes and end with a null byte.
